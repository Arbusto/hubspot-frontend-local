const gulp = require('gulp');
const sass = require('gulp-sass');
const browserSync = require('browser-sync').create();
const sassLint = require('gulp-sass-lint');
const concat = require('gulp-concat');
const eslint = require('gulp-eslint');
const autoprefixer = require('gulp-autoprefixer');
const minifyCSS = require('gulp-clean-css');
const minifyJS = require('gulp-uglify');
const fs = require('fs');
const rp = require('request-promise');
const config = require('./config.json');
const headerComment = require('gulp-header-comment');
const runSeq = require('run-sequence');
const readlineSync = require('readline-sync');
const browserify = require("browserify");
const babelify = require("babelify");
const source = require('vinyl-source-stream');
const buffer = require('vinyl-buffer');
const _ = require('lodash');
const slugify = require('slugify')
const { api_key, files: { html: { hubspot_path } } } = config;

function getFilePath(name) {
  let options = {
    method: 'GET',
    uri: `http://api.hubapi.com/content/api/v2/templates?hapikey=${config.api_key}&label=${name}`,
  };

  return rp(options);
}

const runSassLint = () => {
  return gulp.src('./src/styles/*.scss')
    .pipe(sassLint({
      rules: {
        'mixins-before-declarations': 0,
        'no-transition-all': 0,
        'no-color-keywords': 0,
        'no-color-literals': 0,
        'property-sort-order': 0
      }
    }))
    .pipe(sassLint.format())
    .pipe(sassLint.failOnError())
}
gulp.task('sass-lint', runSassLint);

gulp.task('eslint', ['scripts'], () => {
  gulp.src(["./src/scripts/**/*.js"])
    .pipe(eslint())
    .pipe(eslint.format());
});

gulp.task('scripts', () => {
  return browserify({ debug: true })
    .transform(babelify)
    .require("./src/scripts/main.js", { entry: true })
    .bundle()
    .on('error', function (err) {
      console.log(err);
      process.exit(1);
    })
    .pipe(source('main.js'))
    .pipe(buffer())
    .pipe(minifyJS())
    .pipe(headerComment(`THIS FILE WAS AUTOGENERATED`))
    .pipe(gulp.dest('./dist'));
});

gulp.task('concat-head', () => {
  const main = gulp.src('./src/styles/main.scss')
    .pipe(sass())
    .pipe(minifyCSS())
    .pipe(autoprefixer())

  return main
    .pipe(concat('main.css'))
    .pipe(headerComment("THIS FILE WAS AUTOGENERATED PLEASE DO NOT EDIT, RISK OF OVERWRITE"))
    .pipe(gulp.dest('dist'))
    .pipe(browserSync.reload({ stream: true }));
});

gulp.task('servePage', () => {
  let { css, js } = config.files;

  const jsRewrite = [];
  let showCss = {
    rule: {
      match: /<\/head>/i,
      fn: function (snippet, match) {
        return snippet + match;
      }
    }
  };

  const jsRegex = new Promise((resolve, reject) => {
    if (js.useLocal) {
      if (js.overWriteLocal) {
        const fileLocation = getFilePath('main.js').then((body) => {
          let regVal = `<script .*main.*\.js.*><\/script>`;
          let regex = new RegExp(regVal);

          jsRewrite.push({
            match: regex,
            fn: function (req, res, match) {
              return '<script src="/main.js"></script>';
            }
          });
          resolve();
        }).catch(() => resolve());
      } else {
        jsRewrite.push({
          match: /<\/body>/i,
          fn: function (req, res, match) {
            return '<script src="/main.js"></script>' + match;
          }
        });
        resolve();
      }
    } else {
      resolve();
    }
  });

  const cssRegex = new Promise((resolve, reject) => {
    if (css.useLocal) {
      if (css.overWriteLocal) {
        const fileLocation = getFilePath('main.css').then((body) => {
          let regVal = `<link.*main.*.css.*>`;
          let regex = new RegExp(regVal);

          showCss = {
            rule: {
              match: regex,
              fn: function (snippet, match) {
                return '<link rel="stylesheet" type="text/css" href="/main.css"/>' + snippet;
              }
            }
          }

          resolve();
        }).catch(() => resolve());
      } else {
        showCss = {
          rule: {
            match: /<\/head>/i,
            fn: function (snippet, match) {
              return '<link rel="stylesheet" type="text/css" href="/main.css"/>' + snippet + match;
            }
          }
        }
        resolve();
      }
    } else {
      resolve();
    }
  });

  console.log(`
  Please wait while we get your file paths.
  `);

  Promise.all([jsRegex, cssRegex]).then(() => {
    let { preview_url } = config;
    browserSync.init({
      proxy: {
        target: preview_url
      },
      serveStatic: ["dist"],
      files: ["dist/**", 'src/views/*.html'],
      snippetOptions: showCss,
      rewriteRules: jsRewrite,
      ghostMode: {
        scroll: true
      },
      open: true,
      https: false
    });
    gulp.watch('./src/styles/*.*', ['sass-lint', 'concat-head']).on('change', browserSync.reload);
    gulp.watch('./src/scripts/*.js', ['eslint', 'scripts']).on('change', browserSync.reload);
    gulp.watch('./src/views/*.html', { delay: 2000, ignoreInitial: true }, ['modules', 'views'])
  });
});

gulp.task('assets-prompt', () => {
  if (readlineSync.keyInYN('Are you sure you want to deploy your files? This will overwrite the files already here. (Y for yes, N for no)')) {
    return true;
  }
  console.log('Ok, not deploying. Please update the config and try and again');
  process.exit(1);
});

gulp.task('modules', () => {
  //executed with eval
  const Module = (config) => {
    let { type, fields, name } = config;
    const path = `modules/${type}`;
    const css = fs.readFileSync(`./src/${path}/${type}.css`, "utf8").toString();
    let source = fs.readFileSync(`./src/${path}/${type}.html`, "utf8").toString();
    let fieldsArray = [];
    _.each(fields, (field, key) => {
      if (field && field.label) {
        const name = slugify(field.label, '_').toLowerCase();
        source = source.replace(new RegExp(`^${key}$`, 'g'), name);

        fieldsArray.push({
          type: 'richtext',
          default: name,
          name,
          ...field,
        });
      }
    });

    return {
      global: false,
      name: type,
      isAvailableForNewContent: false,
      hostTemplateTypes: ["PAGE"],
      ...config,
      fields: fieldsArray,
      label: name,
      widgetLabel: name,
      source,
      css,
      schemaVersion: 2,
    }
  }
  fs.readdirSync('./src/views/').forEach(view => {
    let source = fs.readFileSync(`./src/views/${view}`).toString();
    const regex = /Module\([\s\S]*?\)/g;
    const toReplace = source.match(regex);
    if (toReplace) {
      toReplace.forEach(async (moduleString) => {
        const newModule = eval(moduleString.replace(/\s/g, ''));
        fs.writeFileSync(`./src/views/test.html`, newModule.name)
        let update = {};
        let create = {};
        const oldModuleResponse = await rp(`https://api.hubapi.com/content/api/v4/custom-widgets?hapikey=${api_key}&name=${newModule.name}`)
        const oldModule = JSON.parse(oldModuleResponse).objects && JSON.parse(oldModuleResponse).objects[0];
        //fs.writeFileSync(`./src/views/test.html`, JSON.stringify(JSON.parse(response).objects))
        if (!oldModule || !oldModule.id) {
          create = {
            method: 'POST',
            uri: `http://api.hubapi.com/content/api/v4/custom-widgets/?hapikey=${api_key}`,
            headers: {
              'Content-Type': 'application/json'
            },
            body: JSON.stringify(newModule)
          };
        }
        if (oldModule && oldModule.id && !_.isEqual(newModule, oldModule)) {
          update = {
            method: 'PUT',
            uri: `http://api.hubapi.com/content/api/v4/custom-widgets/${oldModule.id}/?hapikey=${api_key}`,
            headers: {
              'Content-Type': 'application/json'
            },
            body: JSON.stringify(newModule)
          };
        }
        const options = update && update.uri ? update : create;
        if (options && options.uri) {
          const moduleResponse = await rp(options);
          const rewriteModules =
            console.log('moduleResponse')
          console.log(moduleResponse)
          return moduleResponse;
        }
      });
    }
  });
});

gulp.task('views', () => {
  const rewriteModules = () => {

  }
  const rewriteIncludes = (viewToRewrite) => {
    let source = viewToRewrite;
    const regex = /{% \binclude_view\b .* %}/g;
    const toReplace = source.match(regex);
    if (toReplace) {
      toReplace.forEach((include) => {
        const viewName = include.replace('include_view', '').replace("{%", '').replace('%}', '').trim();
        const setViewVariable = `{% set ${viewName} = partials_path+"${viewName}.html" %} `;
        source = setViewVariable + source;
      })
      source = source.replace(/include_view/g, 'include'); ``
    }
    return source;
  }

  rp(`http://api.hubapi.com/content/api/v2/templates/?hapikey=${api_key}`)
    .then((response) => {
      let files = {};
      let views = [];
      // Each file grabbed from hubspot
      JSON.parse(response).objects.forEach((file) => {
        if (file.path.includes(hubspot_path) && file.label.endsWith('.html')) {
          files[file.label] = file.id;
        }
      });
      let options = {}
      fs.readdirSync('./src/views/').forEach(view => {
        views.push(view);
        const source = rewriteIncludes(fs.readFileSync(`./src/views/${view}`).toString());

        if (files[view]) {
          options = {
            method: 'PUT',
            uri: `http://api.hubapi.com/content/api/v2/templates/${files[view]}?hapikey=${api_key}`,
            headers: {
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({ source })
          };
        } else {
          options = {
            method: 'POST',
            uri: `http://api.hubapi.com/content/api/v2/templates?hapikey=${api_key}`,
            headers: {
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({
              "category_id": 4,
              "folder": "examples",
              "is_available_for_new_content": "False",
              "template_type": 4,
              "path": `${hubspot_path}/${view}`,
              source
            })
          };
        }
        rp(options);
      });
      const deleted = Object.keys(files).filter(file => !views.includes(file));
      deleted.forEach((view) => {
        const id = files[view];
        rp({
          method: 'DELETE',
          uri: `http://api.hubapi.com/content/api/v2/templates/${id}?hapikey=${api_key}`
        });
      });
    })
});

gulp.task('design-manager', () => {
  let { api_key, files } = config;
  const file = fs.readFileSync(__dirname + '/dist/main.js', 'utf8');

  Object.keys(files).forEach(function (file) {
    let thisFile = files[file];
    if (!thisFile.useLocal) return;
    thisFile.name = thisFile.path.replace('/dist/', '');
    getFilePath(thisFile.name).then((file) => {
      thisFile.id = JSON.parse(file).objects[0].id;
      thisFile.id && fs.readFile(__dirname + thisFile.path, (err, data) => {
        if (err) return console.error(err);

        let source = JSON.stringify({
          "source": data.toString()
        });

        let options = {
          method: 'PUT',
          uri: `http://api.hubapi.com/content/api/v2/templates/${thisFile.id}?hapikey=${api_key}`,
          headers: {
            'Content-Type': 'application/json'
          },
          body: source
        };

        rp(options)
          .then(function (body) {
            let { label, folder_id, path } = JSON.parse(body);
            console.log(`
          File: ${folder_id}
          Label: ${label}
          At: ${path}
          Successfully updated`);
          })
          .catch(function (err) {
            return console.error('Upload Failed:', err);
          });
      });
    });
  });
});

gulp.task('build', ['concat-head', 'scripts', 'modules', 'views']);

gulp.task('default', ['build', 'servePage']);

gulp.task('assets', function () {
  return runSeq('assets-prompt', 'build', 'design-manager');
})
