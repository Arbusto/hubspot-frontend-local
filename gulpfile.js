const gulp = require('gulp');
const sass = require('gulp-sass');
const browserSync = require('browser-sync').create();
const sassLint = require('gulp-sass-lint');
const concat = require('gulp-concat');
const eslint = require('gulp-eslint');
const lintRulesPath = './.eslintrc';
const autoprefixer = require('gulp-autoprefixer');
const minifyCSS = require('gulp-clean-css');
const minifyJS = require('gulp-uglify');
const fs = require('fs');
const rp = require('request-promise');
const config = require('./config.json');
const headerComment = require('gulp-header-comment');
const runSeq = require('run-sequence');
const readlineSync = require('readline-sync');
const browserify = require("browserify");
const babelify = require("babelify");
const source = require('vinyl-source-stream');
const gutil = require('gulp-util');
const buffer = require('vinyl-buffer');


function getFilePath(name) {
  let options = {
    method: 'GET',
    uri: `http://api.hubapi.com/content/api/v2/templates?hapikey=${config.api_key}&label=${name}`,
  };

  return rp(options);
}

const runSassLint = () => {
  return gulp.src('./src/styles/*.scss')
    .pipe(sassLint({
      rules: {
        'mixins-before-declarations': 0,
        'no-transition-all': 0,
        'no-color-keywords': 0,
        'no-color-literals': 0,
        'property-sort-order': 0
      }
    }))
    .pipe(sassLint.format())
    .pipe(sassLint.failOnError())
}
gulp.task('sass-lint', runSassLint);

gulp.task('eslint', ['scripts'], () => {
  gulp.src(["./src/scripts/**/*.js"])
    .pipe(eslint())
    .pipe(eslint.format());
});

gulp.task('scripts', () => {
  return browserify({ debug: true })
    .transform(babelify)
    .require("./src/scripts/main.js", { entry: true })
    .bundle()
    .on('error', function (err) {
      console.log(err);
      process.exit(1);
    })
    .pipe(source('main.js'))
    .pipe(buffer())
    .pipe(minifyJS())
    .pipe(headerComment(`THIS FILE WAS AUTOGENERATED`))
    .pipe(gulp.dest('./dist'));
});

gulp.task('concat-head', () => {
  const main = gulp.src('./src/styles/main.scss')
    .pipe(sass())
    .pipe(minifyCSS())
    .pipe(autoprefixer())

  return main
    .pipe(concat('main.css'))
    .pipe(headerComment("THIS FILE WAS AUTOGENERATED PLEASE DO NOT EDIT, RISK OF OVERWRITE"))
    .pipe(gulp.dest('dist'))
    .pipe(browserSync.reload({ stream: true }));
});

gulp.task('servePage', () => {
  let { css, js } = config.files;

  const jsRewrite = [];
  let showCss = {
    rule: {
      match: /<\/head>/i,
      fn: function (snippet, match) {
        return snippet + match;
      }
    }
  };

  const jsRegex = new Promise((resolve, reject) => {
    if (js.useLocal) {
      if (js.overWriteLocal) {
        const fileLocation = getFilePath('main.js').then((body) => {
          let regVal = `<script .*main.*\.js.*><\/script>`;
          let regex = new RegExp(regVal);

          jsRewrite.push({
            match: regex,
            fn: function (req, res, match) {
              return '<script src="/main.js"></script>';
            }
          });
          resolve();
        }).catch(() => resolve());
      } else {
        jsRewrite.push({
          match: /<\/body>/i,
          fn: function (req, res, match) {
            return '<script src="/main.js"></script>' + match;
          }
        });
        resolve();
      }
    } else {
      resolve();
    }
  });

  const cssRegex = new Promise((resolve, reject) => {
    if (css.useLocal) {
      if (css.overWriteLocal) {
        const fileLocation = getFilePath('main.css').then((body) => {
          let regVal = `<link.*main.*.css.*>`;
          let regex = new RegExp(regVal);

          showCss = {
            rule: {
              match: regex,
              fn: function (snippet, match) {
                return '<link rel="stylesheet" type="text/css" href="/main.css"/>' + snippet;
              }
            }
          }

          resolve();
        }).catch(() => resolve());
      } else {
        showCss = {
          rule: {
            match: /<\/head>/i,
            fn: function (snippet, match) {
              return '<link rel="stylesheet" type="text/css" href="/main.css"/>' + snippet + match;
            }
          }
        }
        resolve();
      }
    } else {
      resolve();
    }
  });

  console.log(`
  Please wait while we get your file paths.
  `);

  Promise.all([jsRegex, cssRegex]).then(() => {
    let { preview_url } = config;
    browserSync.init({
      proxy: {
        target: preview_url
      },
      serveStatic: ["dist"],
      files: ["dist/**", 'src/views/*.html'],
      snippetOptions: showCss,
      rewriteRules: jsRewrite,
      ghostMode: {
        scroll: true
      },
      open: true,
      https: false
    });
    gulp.watch('./src/styles/*.*', ['sass-lint', 'concat-head']).on('change', browserSync.reload);
    gulp.watch('./src/scripts/*.js', ['eslint']);
    gulp.watch('./src/views/*.html', ['views']);
  });
});

gulp.task('assets-prompt', () => {
  if (readlineSync.keyInYN('Are you sure you want to deploy your files? This will overwrite the files already here. (Y for yes, N for no)')) {
    return true;
  }
  console.log('Ok, not deploying. Please update the config and try and again');
  process.exit(1);
});

gulp.task('views', () => {
  const rewriteIncludes = (viewToRewrite) => {
    let source = viewToRewrite;
    const regex = /{% \binclude_view\b .* %}/g;
    const toReplace = source.match(regex);
    if (toReplace) {
      toReplace.forEach((include) => {
        const viewName = include.replace('include_view', '').replace("{%", '').replace('%}', '').trim();
        const setViewVariable = `{% set ${viewName} = partials_path+"${viewName}.html" %} `;
        source = setViewVariable + source;
      })
      source = source.replace(/include_view/g, 'include');
    }
    return source;
  }
  const { api_key, files: { html: { hubspot_path } } } = config;
  rp(`http://api.hubapi.com/content/api/v2/templates/?hapikey=${api_key}`)
    .then((response) => {
      let files = {};
      let views = [];
      JSON.parse(response).objects.forEach((file) => {
        if (file.path.includes(hubspot_path) && file.label.endsWith('.html')) {
          files[file.label] = file.id;
        }
      });
      let options = {}
      fs.readdirSync('./src/views/').forEach(view => {
        views.push(view);
        const source = rewriteIncludes(fs.readFileSync(`./src/views/${view}`).toString());
        if (files[view]) {
          options = {
            method: 'PUT',
            uri: `http://api.hubapi.com/content/api/v2/templates/${files[view]}?hapikey=${api_key}`,
            headers: {
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({ source })
          };
        } else {
          options = {
            method: 'POST',
            uri: `http://api.hubapi.com/content/api/v2/templates?hapikey=${api_key}`,
            headers: {
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({
              "category_id": 4,
              "folder": "examples",
              "is_available_for_new_content": "False",
              "template_type": 4,
              "path": `${hubspot_path}/${view}`,
              source
            })
          };
        }
        rp(options);
      });
      const deleted = Object.keys(files).filter(file => !views.includes(file));
      deleted.forEach((view) => {
        const id = files[view];
        rp({
          method: 'DELETE',
          uri: `http://api.hubapi.com/content/api/v2/templates/${id}?hapikey=${api_key}`
        });
      });
    })
});

gulp.task('design-manager', () => {
  let { api_key, files } = config;

  const file = fs.readFileSync(__dirname + '/dist/main.js', 'utf8');

  Object.keys(files).forEach(function (file) {
    let thisFile = files[file];
    if (!thisFile.useLocal) return;

    if (!thisFile.id) return console.error(`Please give your ${file} file an ID in config.json`);

    let fileString = fs.readFile(__dirname + thisFile.path, (err, data) => {
      if (err) return console.error(err);


      let source = JSON.stringify({
        "source": data.toString()
      });

      let options = {
        method: 'PUT',
        uri: `http://api.hubapi.com/content/api/v2/templates/${thisFile.id}?hapikey=${api_key}`,
        headers: {
          'Content-Type': 'application/json'
        },
        body: source
      };

      rp(options)
        .then(function (body) {
          let { label, folder_id, path } = JSON.parse(body);
          console.log(`
          File: ${folder_id}
          Label: ${label}
          At: ${path}
          Successfully updated`);
        })
        .catch(function (err) {
          return console.error('Upload Failed:', err);
        });

    });
  })
});

gulp.task('build', ['concat-head', 'scripts', 'views']);

gulp.task('default', ['build', 'servePage']);

gulp.task('assets', function () {
  return runSeq('assets-prompt', 'build', 'design-manager');
})
